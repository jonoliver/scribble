{"version":3,"sources":["js/worker.js"],"names":["words","onmessage","e","type","data","calculate","combo","isWord","includes","w","postIsWord","isaWord","postMessage","match","heapPermuations","arr","permutations","generate","n","push","join","i","b","tmp","a","swap","length","unique","value","index","self","indexOf","mapAlphabetic","reduce","obj","key","allPerms","letters","perms","myPerms","map","perm","slice","concat","alphaWords","filter","alphaPerms","keys","Object","thesePerms","theseWords","isMatch"],"mappings":";AAAA,IAAIA,OAAJ,EAEAC,UAAY,SAACC,GACHC,IAAAA,EAASD,EAAEE,KAAXD,KACJA,GAAS,SAATA,EAIAA,GAAS,SAATA,OAAAA,CACIC,IAAAA,EAAOC,EAAUH,EAAEE,KAAKE,OAClBF,YAAAA,QALJF,EAAAA,EAAEE,KAAKJ,OAUnB,IAAMO,EAAS,SAAA,GAAKP,OAAAA,EAAMQ,SAASC,IAE7BC,EAAa,SAAK,GAChBC,IAAAA,EAAUJ,EAAOE,GAEhBE,OADHA,GAASC,YAAY,CAAEC,MAAOJ,IAC3BE,GAGT,SAASG,EAAgBC,GAEjBC,IAAAA,EAAe,GAqBdA,OAZEC,SAAAA,EAASC,GACZA,GAAK,GAALA,EACWC,EAAAA,KAAKJ,EAAIK,KAAK,UAEtB,IAAA,IAAIC,EAAI,EAAGA,GAAKH,IAAKG,EACfH,EAAAA,EAAI,GAZFI,EAaSJ,EAAI,EAXxBK,EAAMR,EAFES,EAaHN,EAAI,EAAI,EAAIG,GAVjBG,EAAAA,GAAKT,EAAIO,GACTA,EAAAA,GAAKC,EAJFE,IAAKD,EAAGF,EAEXC,EAgBGR,CAAAA,EAAIW,QACNV,EAGT,IAAMW,EAAS,SAACC,EAAOC,EAAOC,GAASA,OAAAA,EAAKC,QAAQH,KAAWC,GAEzDG,EAAgB,SAACjB,GAAQA,OAAAA,EAAIkB,OAAO,SAACC,EAAKzB,GACxC0B,IAAAA,EAAM1B,EAAE,GAGPyB,OAFFA,EAAIC,KAAWA,EAAAA,GAAO,IACvBA,EAAAA,GAAKhB,KAAKV,GACPyB,GACL,KAEJ,SAASE,EAASC,GAGX,IAFCC,IAAAA,EAAQxB,EAAgBuB,GAC1BD,EAAW,GACNf,EAAI,EAAGA,EAAI,EAAGA,IAAK,CACpBkB,IAAAA,EAAUD,EAAME,IAAI,SAAA,GAAQC,OAAAA,EAAKC,MAAM,EAAGD,EAAKf,OAASL,KACnDe,EAAAA,EAASO,OAAOJ,GAEtBH,OAAAA,EAIT,SAAS/B,EAAUgC,GACXO,IAAAA,EAAaZ,EAAchC,GAC3BsC,EAAQF,EAASC,GAASQ,OAAOlB,GACjCmB,EAAad,EAAcM,GAE1BS,OADMC,OAAOD,KAAKD,GACbb,OAAO,SAAClB,EAAKoB,GACjBc,IAAAA,EAAaL,EAAWT,GACxBe,EAAaJ,EAAWX,GAOvBpB,OANDA,EAAAA,EAAI4B,OAAOM,EAAWJ,OAAO,SAAK,GAChCM,IAAAA,EAAUD,EAAW1C,SAASC,GAE7B0C,OADHA,GAASvC,YAAY,CAAEC,MAAOJ,IAC3B0C,MAIR","file":"worker.afcbb442.map","sourceRoot":"..","sourcesContent":["let words;\n\nonmessage = (e) => {\n  const { type } = e.data;\n  if (type === \"init\"){\n    words = e.data.words;\n    return;\n  }\n  if (type === \"calc\"){\n    const data = calculate(e.data.combo);\n    postMessage(data);\n    return;\n  }\n}\n\nconst isWord = w => words.includes(w);\n\nconst postIsWord = w => {\n  const isaWord = isWord(w);\n  if (isaWord) postMessage({ match: w });\n  return isaWord;\n}\n\nfunction heapPermuations(arr)\n{\n  const permutations = [];\n\n  function swap(a, b)\n  {\n    var tmp = arr[a];\n    arr[a] = arr[b];\n    arr[b] = tmp;\n  }\n\n  function generate(n) {\n    if (n == 1) {\n      permutations.push(arr.join(''));\n    } else {\n      for (var i = 0; i != n; ++i) {\n        generate(n - 1);\n        swap(n % 2 ? 0 : i, n - 1);\n      }\n    }\n  }\n\n  generate(arr.length);\n  return permutations;\n}\n\nconst unique = (value, index, self) => self.indexOf(value) === index;\n\nconst mapAlphabetic = (arr) => arr.reduce((obj, w) => {\n  const key = w[0];\n  if (!obj[key]){ obj[key] = []};\n  obj[key].push(w);\n  return obj;\n} , {});\n\nfunction allPerms(letters){\n  const perms = heapPermuations(letters);\n  let allPerms = []\n  for (var i = 0; i < 6; i++) {\n    const myPerms = perms.map(perm => perm.slice(0, perm.length - i))\n    allPerms = allPerms.concat(myPerms)\n  }\n  return allPerms;\n}\n\n\nfunction calculate(letters){\n  const alphaWords = mapAlphabetic(words);\n  const perms = allPerms(letters).filter(unique);\n  const alphaPerms = mapAlphabetic(perms);\n  const keys = Object.keys(alphaPerms);\n  return keys.reduce((arr, key) => {\n    const thesePerms = alphaWords[key];\n    const theseWords = alphaPerms[key];\n    arr = arr.concat(thesePerms.filter(w => {\n      const isMatch = theseWords.includes(w);\n      if (isMatch) postMessage({ match: w });\n      return isMatch;\n    }));\n\n    return arr;\n  }, []);\n}\n"]}